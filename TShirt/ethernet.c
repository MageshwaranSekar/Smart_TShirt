#include "ethernet.h"
#include <stdint.h>
#include <stdio.h>
#include "serial.h"

/* SLIP special character codes */
#define END             0xC0    /* indicates end of packet */
#define ESC             0xDB    /* indicates byte stuffing */
#define ESC_END         0xDC    /* ESC ESC_END means END data byte */
#define ESC_ESC         0xDD    /* ESC ESC_ESC means ESC data byte */

uint8_t parityTab[256];

uint8_t evenParity(uint8_t ch){	//returns false:0 if odd, true:1 if even
	int i;
	for(i=4;i>0;i>>=1) ch ^= (ch >> i);
	return (~ch) & 0x01;
}

void initParityTable(){
	unsigned int i;
	for(i=0; i<256; i++)
		parityTab[i]=evenParity((uint8_t)i);
}

uint8_t checkParity(uint8_t x, uint8_t y, uint8_t z, uint8_t t){
	return (((parityTab[x]<<3) | (parityTab[y]<<2) | (parityTab[z]<<1) | (parityTab[t])) & 0x0F);
}



void data_packet(unsigned int teamid, unsigned int x, unsigned int y, unsigned int z, unsigned int t, uint8_t packet[5]){
	packet[1]=(uint8_t)x;
	packet[2]=(uint8_t)y;
	packet[3]=(uint8_t)z;
	packet[4]=(uint8_t)t;
	uint8_t idsum=(uint8_t)teamid;
	packet[0]=idsum;
}

void udp_packet(uint8_t udpp[13], uint8_t packet[5]){
	udpp[0]=0x30; //Port Source
	udpp[1]=0x39;
	udpp[2]=0x30; //Port Dest
	udpp[3]=0x39;
	//udpp[2]=0x23; //Port Dest
	//udpp[3]=0x29;
	udpp[4]=0x00; //Taille
	udpp[5]=0x0D;
	udpp[6]=0x00; //CRC
	udpp[7]=0x00;
	int i=0;
	for (i=0;i<5;i++)
		udpp[8+i]=packet[i];
}

void ip_packet(uint8_t ipp[33], uint8_t udpp[13]){
  ipp[0]=0x45; //IPv4+IHL
  ipp[1]=0x00; //TOS
 
  ipp[2]=0x00; //LGTH
  ipp[3]=0x21;
  
  ipp[4]=0x00; //IDENT
  ipp[5]=0x00;
  
  ipp[6]=0x00; //INDIC
  ipp[7]=0x00; //FRAG OFFSET
  
  ipp[8]=0xFF;
  ipp[9]=0x11;
  
  ipp[10]=0xC3;//CRC
  ipp[11]=0xC6;
  
  ipp[12]=0xAC; //172
  ipp[13]=0x1A; //.26
  
  ipp[14]=0x4F; //.79
  ipp[15]=0xD1; //209
  
  ipp[16]=0xAC; //172
  ipp[17]=0x1A; //.26
  
  ipp[18]=0x4F; //.79
  //ipp[19]=0xD0; //208
  ipp[19]=0XFF;
  int i=0;
  for (i=0;i<13;i++) ipp[20+i]=udpp[i];

  //CRC
  
}



/* SEND_PACKET: sends a packet of length "len", starting at
* location "p".
*/
void send_packet(unsigned char *p, int len){

	/* send an initial END character to flush out any data that may
	* have accumulated in the receiver due to line noise */
	send_serial(END);

	/* for each byte in the packet, send the appropriate character
	* sequence */
	while(len--) {
		switch(*p) {
			/* if it's the same code as an END character, we send a
			* special two character code so as not to make the
			* receiver think we sent an END */
			case END:
				send_serial(ESC);
				send_serial(ESC_END);
				break;

			/* if it's the same code as an ESC character,
			* we send a special two character code so as not
			* to make the receiver think we sent an ESC
			*/
			case ESC:
				send_serial(ESC);
				send_serial(ESC_ESC);
				break;

			/* otherwise, we just send the character */
			default:
				send_serial(*p);
		}
		p++;
	}

	/* tell the receiver that we're done sending the packet */
	send_serial(END);
}

/* RECV_PACKET: receives a packet into the buffer located at "p".
*      If more than len bytes are received, the packet will
*      be truncated.
*      Returns the number of bytes stored in the buffer. */
unsigned int recv_packet(unsigned char *p, int len){
	unsigned char c;
	int received = 0;

	/* sit in a loop reading bytes until we put together
	* a whole packet.
	* Make sure not to copy them into the packet if we
	* run out of room.
	*/
	while(1){
		/* get a character to process
		*/
		c = get_serial();

		/* handle bytestuffing if necessary
		*/
		switch(c) {
			/* if it's an END character then we're done with
			* the packet
			*/
			case END:
			/* a minor optimization: if there is no
			* data in the packet, ignore it. This is
			* meant to avoid bothering IP with all
			* the empty packets generated by the
			* duplicate END characters which are in
			* turn sent to try to detect line noise.
			*/
			if(received) return received;
			else break;

			/* if it's the same code as an ESC character, wait
			* and get another character and then figure out
			* what to store in the packet based on that.
			*/
			case ESC:
				c = get_serial();

				/* if "c" is not one of these two, then we
				* have a protocol violation.  The best bet
				* seems to be to leave the byte alone and
				* just stuff it into the packet
				*/
				switch(c) {
					case ESC_END:
						c = END;
						break;
					case ESC_ESC:
						c = ESC;
						break;
				}

			/* here we fall into the default handler and let
			* it store the character for us */
			default:
				if(received < len) p[received++] = c;
		}
	}
}

uint8_t read_packet(unsigned char *ipp){
	if(ipp[0]==0x45){//Si Paquet IPv4
		if((ipp[12]==0xAC)&&(ipp[13]==0x1A)&&(ipp[14]==0x4F)&&(ipp[15]==0xD0)){	//Si IP Source 172.26.79.208 (Foxboard)
			if((ipp[22]==0x30)&&(ipp[23]==0x39)&&((ipp[28]&0xF0)==0x40)){ //Si Port Dest est bien 12345
				if((ipp[28]&0x0F)== checkParity(ipp[29], ipp[30], ipp[31], ipp[32])){
					if(ipp[29]==0 && ipp[30]==0 && ipp[31]==0){//frequency
						return ipp[32];
					}	
				}		
			}
		}
	}
	return 0;
}
